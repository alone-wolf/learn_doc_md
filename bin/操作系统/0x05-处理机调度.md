# 处理机调度

## 3 调度算法

### 1先来先服务算法 FCFS  Frist Come First Served

- 对于作业调度，从后备作业中选择最先进入该队列的作业，将他们调入内存，为他们分配资源、创建进程，然后放入就绪队列
- 对于进程调度，从就绪队列中选择最先进入该队列的进程，分配处理机，使之运行

#### 特点

易于实现 有利于长作业，短作业不满

### 2短作业（进程）优先调度算法 SJF Short Job First

- 短作业优先是从后备队列中选择估计运行时间最短的作业，将它们调入内存
- 短进程优先是从就绪队列中选择估计运行时间最短进程，将处理机分配给它，使之执行并一直到完成或因发生某事件而阻塞放弃处理机时，再重新调度

#### 特点

- 极端情况下，长作业得不到调度
- 作业或进程的长短只能估计，不准确
- 完全不考虑紧迫程度，使紧急事件得不到处理

### 3时间片轮转调度算法

#### 算法思想

* 进程按FCFS在就绪队列排队，调度程序把CPU分配给队首进程，令其执行一个时间片，一个时间片执行完毕将进程排在队尾

#### 时间片大小确定

响应时间T=用户数目N*时间片q

* 响应时间T
  * 当N一定，T与q成正比。T若要求快，则q也要小
* 就绪队列的进程数N
  * T一定，q与N成反比。N越多，q越少
* 系统处理能力
  * 保证用户键入的常用命令能在一个时间片内处理完毕
* 时间片稍大于交互时间 则有空闲时间
* 时间片小于交互时间 第二个时间片继续运行

| \\|很小的时间片 | 太长的时间片 |
| -------------- | ------------ | -------------- |
| 优点 | 有利于短作业 |每个进程都能在一个时间片内完成，无法满足交互式用户的需求|
| 缺点 | 频繁得发生中断 |中断不会频繁发生|

一个较为可取得大小是，时间片略大于一次典型得交互所需要的时间。这样可使大多数进程在一个时间片内完成

### 4优先权调度算法

#### 算法思想

- 从后备队列中选择若干优先权最高的作业，将它们调入内存
- 或从就绪队列中选择优先权最高的进程，将处理机分配给它

#### 优先权类型

- 静态优先权
  - 确定因素：进程类型、进程对资源的需求、用户要求
- 动态优先权
  - 确定因素：等待时间、运行时间

#### 特点

综合考虑各种情况



常被用于批处理系统中，作为作业调度算法，也作为多种操作系统中的进程调度算法，还可用于实时系统中

#### 1 用作进程调度时，分两种

* 非抢占式优先权算法
  * 在这种方式下，系统一旦把处理机分配给就绪队列中优先权最高的进程后，该进程便一直执行下去，直至完成；或因发生某事件使该进程放弃处理机时，系统方可再将处理机重新分配给另一优先权最高的进程
* 抢占式优先权调度算法
  * 在这种方式下，系统同样是把处理机分配给优先权最高的进程，使之执行

每当系统中出现一个新的就绪进程i时，就将其优先权Pi与正在执行的进程j的优先权Pj进行比较。如果Pi≤Pj，原进程Pj便继续执行；但如果是Pi>Pj，则立即停止Pj的执行，做进程切换，使i进程投入执行

#### 优点

能更好地满足紧迫作业的要求

#### 2 优先权的类型

##### （1）静态优先权

* 在创建进程时确定的，且在进程的整个运行期间保持不变
1. 进程类型 通常，系统进程的优先权高于一般用户进程的优先权
2. 进程对资源的需求 对要求少的进程应赋予较高的优先权
3. 用户要求 由用户进程紧迫程度及用户所付费的多少来确定优先权

静态优先权法简单易行，系统开销小，但不够精确，很可能出现优先权低的作业（进程）长期没有被调度的情况

##### （2）动态优先权

* 创建进程时赋予的优先权，可以随进程的推进或随其等待时间的增加而改变，以便获得更好的调度性能

例：规定在就绪队列中的进程，随其等待时间的增长，其优先权以速率a提高。所有进程具有相同的优先权初值，最先进入就绪队列的进程将因其动态优先权变得最高而优先获得处理机，等同于FCFS算法；所有就绪进程具有各不相同的优先权初值，对于优先权初值低的进程，等待足够时间后，其优先权便可能升为最高，从而可以获得处理机

当采用抢占式优先权调度算法时，如果再规定当前进程的优先权以速率b下降，则可防止一个长作业长期地垄断处理机

### 5多级反馈队列

#### 算法思想

* 根据作业的性质和类型不同，将就绪队列再分为若干个子队列，每个进程分属于一个队列
* 在多级队列的基础上，不但设多个队列，且为每个队列赋予不同的优先权，第一个队列的优先权最高，第二个队列次之，其余队列的优先权逐个降低
* 各个队列中的进程执行时间片大小逐渐增大
* 新进程投入第一个队列
* 调度从第一个队列进行，仅当第一个队列为空时，才调度第二个队列中的进程

#### 多级反馈队列调度算法具有较好的性能，能很好地满足各种类型用户的需要

##### （1）终端型作业用户

由于终端型作业用户所提交的作业大多属于交互型作业，作业通常较小，系统只要能使这些作业(进程)在第1队列所规定的时间片内完成，便可使终端型作业用户都感到满意

#### （2）短批处理作业用户

开始时像终端型作业一样，如果仅在第一队列中执行一个时间片即可完成，便可获得与终端型作业一样的响应时间。对于稍长的作业，通常也只需在第二队列和第三队列各执行一个时间片即可完成，其周转时间仍然较短

#### （3）长批处理作业用户

对于长作业，它将依次在第1，2，…，n个队列中运行，然后再按轮转方式运行，用户不必担心其作业长期得不到处理

### 6高响应比优先调度算法

在批处理系统中，引入动态优先权，使作业的优先级随着等待时间的增加而以速率a提高，则长作业在等待一定的时间后，必然有机会分配到处理机

该优先权的变化规律：优先权=(等待时间+要求服务时间)/要求服务时间

![image-20200605190632777](C:\Users\10316\Documents\GitHub\learn_doc_md\操作系统\5.assets\image-20200605190632777.png)

1. 作业的Tw相同，Tas越短，Rp越高，有利于短作业
2. Tas相同，优先权决定于Tw，Tw越长，Pr越高，实现的是先来先服务
3. 对于长作业，Rp随Tw的增加而提高，当Tw足够长时，优先级可升到很高，从而也可获得处理机

该算法实现了较好的折中，但每次计算响应比会增加计算量！

## 4 实时调度

### 4.1 实现实时调度的基本条件

#### 1.提供必要的信息

* （1）就绪时间：该任务成为就绪状态的起始时间
* （2）开始截止时间和完成截止时间：？
* （3）处理时间：任务从开始执行到完成所需时间
* （4）资源要求：是指任务执行时所需的一组资源
* （5）优先级

#### 2.系统处理能力强

![image-20200605191210835](C:\Users\10316\Documents\GitHub\learn_doc_md\操作系统\5.assets\image-20200605191210835.png)

#### 3.采用抢占式调度机制

在含有硬实时任务的实时系统中，广泛采用抢占机制

当一个优先权更高的任务到达时，允许将当前任务暂时挂起，而令高优先权任务立即投入运行，这样便可满足该硬实时任务对截止时间的要求。但这种调度机制比较复杂

#### 4.具有快速切换机制

##### 目的：能进行任务的快速切换以保证要求较高的硬实时任务能及时运行

##### 能力：

1. 对外部中断的快速响应能力
   1. 要求系统具有快速硬件中断机构
   2. 应使禁止中断的时间间隔尽量短，以免耽误时机（其他紧迫任务）
2. 快速的任务分配能力

#### 4.2 实时调度算法的分类

1. 非抢占式调度算法

   1. 非抢占式轮转调度算法

   常用于工业生产的群控系统中，由一台计算机控制若干个相同的(或类似的)对象，为每一个被控对象建立一个实时任务，并将它们排成一个轮转队列

   响应时间：数秒至数十秒，可用于要求不太严格的实时控制系统中 

   2. 非抢占式优先调度算法

   为要求较为严格(响应时间为数百毫秒)的任务赋予较高的优先级。当这些实时任务到达时，把它们安排在就绪队列的队首，等待当前任务自我终止或运行完成后才能被调度执行(即使该任务的优先级高于当前任务的优先级也不抢占)

   响应时间：数百毫秒至数秒，可用于有一定要求的实时控制系统

2. 抢占式调度算法

	根据抢占发生时间的不同而进一步分成
	
	1. 基于时钟中断的抢占式优先权调度算法
	
	在某实时任务到达后，如果该任务的优先级高于当前任务的优先级，这是并不立即抢占当前任务的处理机，而是等到时钟中断到来时，调度程序才剥夺当前任务的执行，发生抢占
	
	调度延迟可降到几毫米至几十毫秒，可用于大多数的实时系统
	
	2. 立即抢占的优先权调度算法
	
	要求操作系统具有快速响应外部事件中断的能力。一旦出现外部中断，只要当前任务未处于临界区，便立即剥夺当前任务的执行，把处理机分配给请求中断的紧迫任务
	
	非常快的响应，调度延迟降低到100微秒至几毫秒，甚至更低

#### 4.3 常用的几种实时调度算法

##### 1.最早截止时间优先即EDF(Earliest Deadline First)算法，根据任务的开始截止时间来确定任务的优先级。截止时间愈早，其优先级愈高。可用于抢占式调度、非抢占式调度方式中

##### 2.最低松弛度优先(Least Laxity First)算法，该算法是根据任务紧急(或松弛)的程度，来确定任务的优先级。任务的紧急程度愈高，为该任务所赋予的优先级就愈高

松弛度=必须完成的时间-其本身的运行时间-当前时间

在实现该算法时要求系统中有一个按松弛度排序的实时任务就绪队列，松弛度最低的任务排在队列最前面，调度程序总是选择就绪队列中的队首任务执行







