

# 第三讲 进程控制及状态转换

## 一 进程的引入

### 1 程序的执行顺序及其特点

仅当前一操作(程序段)执行完后，才能执行后继操作

#### 特点

* 顺序性 处理机的操作严格按规定顺序执行
* 封闭性 程序执行时，独占系统资源
* 可再现性 当初始条件相同时，程序多次执行的结果相同

### 2 前趋图 Precedence Graph

一个有向无循环图，记为DAG(Directed Acyclic Graph)，用于描述进程之间执行的前后关系

* 有向边
* 前趋关系（偏序）
* 直接前趋
* 直接后继
* 初始节点
* 终止节点
* 重量
* 在前趋图中，把没有前趋的结点称为初始结点(Initial Node)，把没有后继的结点称为终止结点(Final Node)
* 每个结点具有一个重量(Weight)，表示该结点所含有的程序量或结点的执行时间
* 绝对没有循环
* <img src="C:\Users\10316\Documents\GitHub\learn_doc_md\操作系统\3.assets\image-20200603121836219.png" alt="image-20200603121836219" style="zoom: 67%;" />
* ![image-20200603122058082](C:\Users\10316\Documents\GitHub\learn_doc_md\操作系统\3.assets\image-20200603122058082.png)



### 3 程序的并发执行及其特点

#### 特点

##### 间断性

程序在并发执行时，形成了相互制约关系。相互制约将导致并发程序具有“执行—暂停—执行”这种间断性的活动规律

##### 失去封闭性 
系统中的资源供多个程序共享，致使程序的运行失去了封闭性，系统中的资源由多个程序共享，资源的状态不再只由一个程序改变

##### 失去可再现性

是因为共享了诸如变量这一类的资源，但是未施加控制机制

## 二 进程的定义与状态

通常的程序并发执行使结果具有不可再现性因而失去了意义。为了使程序能够并发执行，即使结果可再现，必须对并发执行的程序加以描述和控制，所以引入了进程的概念

### 1 进程的定义

可并发执行的程序在一个数据集合上的执行过程

进程是进程实体的运行过程，是系统进行资源分配和调度的一个独立单位

### 2 进程的特征

#### 1 结构特征

为程序（含数据）配置了进程控制块(Process Control Block)PCB。

进程的结构：由程序段、数据段、PCB三部分构成

#### 2 动态性

进程的实质是进程的一次执行过程，具有生命周期（产生->执行->消亡）

#### 3 并发性

多个进程能够并发执行

#### 4 独立性

在传统的OS中，进程实体是一个能独立运行、独立分配资源、独立接受调度的基本单位

#### 5 异步性

由于并发的进程之间形成相互制约的关系，进程按照各自独立、不可预知的速度向前推进

### 3 进程与程序的关系

| 进程                       | 程序   |
| -------------------------- | ------ |
| 动态的                     | 静态的 |
| 并发                       | 顺序   |
| 暂时                       | 永久   |
| 数据结构=程序+数据+PCB     |        |
| 进程与程序不是一一对应关系 |        |

###4 进程的三种基本状态

#### （1）就绪状态

进程已经获得了除CPU之外的所有必要的资源。处于就绪状态的进程可以有多个，这些进程排成一个队列，即就绪队列

#### （2）执行状态

已经获得了CPU，正在执行

#### （3）阻塞状态

处于执行状态的进程，由于发生某事件而无法继续执行，便放弃处理机而处于暂停的状态，这种状态称为阻塞状态

这些进程被组织成阻塞队列，有些系统中可以根据引起阻塞的事件不同而组织多个阻塞队列

#### 三种基本状态的比较

| 0              | 就绪状态 | 执行状态                   | 阻塞状态   |
| -------------- | -------- | -------------------------- | ---------- |
| 是否获得CPU    | 没有     | 有                         | 没有       |
| 进程个数       | 可以多个 | 单处理机一个，多处理机多个 | 可以有多个 |
| 进程能否被调度 | 能       | ————                       | 不能       |



## 三 进程控制块

### 1 PCB作用

PCB是进程实体的一部分，是OS中最重要的数据结构

PCB是进程存在的唯一标志，贯穿于进程的整个生命周期。PCB应常驻内存，以链表(或队列)的形式存放在OS中专门开辟的PCB区内

#### 进程的组成

* PCB
* 程序段
* 数据段
* 堆栈

#### 作用

* 引入PCB的作用：就是使程序能成为独立运行的单位，并可和其他进程并发执行

### 2 PCB内容

#### 进程描述信息

* 进程名
* 进程标识符
* 用户名

#### 进程调度信息

* 进程状态
* 进程优先级
* 运行统计信息
* 进程阻塞原因

#### 处理机状态信息

* 通用寄存器
* 指令计数器
* 程序状态字寄存器
* 栈指针

#### 进程控制和资源占有量信息

* 程序入口地址
* 程序的外存地址
* 进程同步及通信机制
* 资源占有信息
* 链接指针

### 3 进程控制块的组织方式

##### 链接方式

![image-20200603124704460](C:\Users\10316\Documents\GitHub\learn_doc_md\操作系统\3.assets\image-20200603124704460.png)

![image-20200603124727332](C:\Users\10316\Documents\GitHub\learn_doc_md\操作系统\3.assets\image-20200603124727332.png)

##### 索引方式

![image-20200603124803041](C:\Users\10316\Documents\GitHub\learn_doc_md\操作系统\3.assets\image-20200603124803041.png)

## 四 进程控制

### 1 主要任务

进程控制一般由OS内核来完成，OS的内核通过原语（Primitive）来实现进程控制。使用原语的目的是为了避免造成进程状态的不确定性。原语在执行时不允许被中断。

#### 创建进程

#### 撤销进程

#### 实现进程状态转换

### 1.1 四个名词

#### 核心态

* 具有较高的特权，能执行一切命令，访问所有寄存器和存储区

#### 用户态

* 具有较低特权，只能执行规定的命令，访问指定的寄存器和存储区

#### 内核

* 硬件的第一次延申
* 系统将一些与硬件紧密相关的模块放在内核
  * 中断处理
  * 时钟管理
* 内核在执行某些基本操作时，往往是利用原语操作实现的

#### 原语

* 原语由若干条指令构成、用于完成一定功能的过程
* 原语是“原子操作”。即一个操作中的所有动作，要么全做，要么全不做。换言之，原子操作是一个不可分割的操作

### 2 进程控制的典型动作

#### 进程控制原语

| 操作 | 原语    |
| ---- | ------- |
| 创建 | creat   |
| 终止 | exit    |
| 阻塞 | block   |
| 唤起 | wakeup  |
| 挂起 | suspend |
| 激活 | active  |



#### （1）进程的创建

使用进程树标明一个进程的父进程和子进程

![image-20200603165712943](C:\Users\10316\Documents\GitHub\learn_doc_md\操作系统\3.assets\image-20200603165712943.png)

* 引起进程创建的事件
  * 用户登录
  * 新作业进入系统
  * 提供服务
  * 应用请求
* 创建 原语要做的工作
  * 申请空白PCB
  * 为进程分配资源
  * 初始化PCB
    * 初始化进程描述信息
    * 初始化处理机状态信息
    * 初始化进程控制信息
  * 将新进程插入就绪队列

#### （2）进程的终止

* 引起进程终止的事件
  * 进程正常终止
  * 进程异常结束
  * 外界干预
* 终止原语要做的工作
  * 查找终止进程的PCB
  * 若进程处于执行状态，终止，并进行进程调度
  * 若有子孙，予以终止
  * 归还资源
  * 从所在队列移出

#### （3）进程的阻塞与唤醒

* 触发
  * 请求系统服务
  * 启动某种操作
  * 数据尚未到达
  * 无新工作可做
* 阻塞原语工作
  * 停止进程的执行
  * 将进程插入阻塞队列，改变进程在PCB中的状态
  * 重新调度
* 唤醒原语工作
  * 将进程从阻塞队列解下
  * 将进程插入就绪队列
  * 改变进程在PCB中的状态

#### （4）进程的挂起与激活

* 挂起原语工作

  * 检查被挂起进程的状态
  * 如进程处于就绪状态，将进程从就绪状态变为就绪挂起状态
  * 如进程处于阻塞状态，将进程从阻塞状态变为阻塞挂起状态
  * 如进程正在运行，将进程变为就绪挂起状态，并重新调度

* 激活原语工作

  * 检查被激活进程的状态
  * 如进程处于就绪挂起状态，将进程从就绪挂起状态变为就绪状态
  * 如进程处于阻塞挂起状态，将进程从阻塞挂起状态变为阻塞状态
  * 若系统为抢占式系统，则进行进程调度

  

## 五 状态间转换

  <img src="C:\Users\10316\Documents\GitHub\learn_doc_md\操作系统\3.assets\image-20200603173059901.png" alt="image-20200603173059901" style="zoom:67%;" />

阻塞的原因解除，排在阻塞队列的进程可以进入就绪队列，这个进程不能立即获得处理机执行

  <img src="C:\Users\10316\Documents\GitHub\learn_doc_md\操作系统\3.assets\image-20200603173148925.png" alt="image-20200603173148925" style="zoom:67%;" />

  <img src="C:\Users\10316\Documents\GitHub\learn_doc_md\操作系统\3.assets\image-20200603173253918.png" alt="image-20200603173253918" style="zoom:67%;" />

<img src="C:\Users\10316\Documents\GitHub\learn_doc_md\操作系统\3.assets\image-20200603173350085.png" alt="image-20200603173350085" style="zoom:67%;" />



### 1 状态转换过程

1. 处于后备队列上的作业经作业调度进入内存，然后为作业创建了一个或多个进程
2. 这些进程进入就绪队列等待进程调度，这时这些进程处于就绪状态
3. 经过进程调度后，一个进程获得处理机，这个进程就处于执行状态，没有获得处理机的其他进程仍然处于就绪状态

### 2 处于执行状态的进程在执行过程中会遇到几种情况

| 多道批处理系统                                               | 分时系统                                                     |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
| 进程未执行完，发生了引起进程阻塞的事件，于是进程放弃处理机不再继续执行，进入阻塞队列，这时这个进程处于阻塞状态 | 进程未执行完一个时间片，发生了引起进程阻塞的事件，于是进程放弃处理机不再继续执行，进入阻塞队列，这时这个进程处于阻塞状态 |
|                                                              | 进程未执行完一个时间片，发生了抢占，于是进程放弃处理机不再继续执行，进入就绪队列等待下次调度，这时这个进程处于就绪状态 |
|                                                              | 进程执行完一个时间片，这期间没有发生引起进程阻塞的事件，也没有发生抢占，进程也放弃处理机不再继续执行，而进入就绪队列等待下次调度，这时这个进程处于就绪状态 |

### 3 挂起状态

* 指把一个进程从内存换到外存
* 引起挂起的原因
  * 内存资源已不能满足进程运行需要，挂起某些进程以腾出内存空间供其它进程使用
  * 系统中的进程过多，负荷过重，需要挂起一部分进程以保证系统能正常运行
  * 用户发现进程有问题，要求挂起自己的进程，以便进行检查和修改
  * 父进程希望挂起自己的某个子进程，以便进行检查和修改

### 4 两种挂起状态

进程被挂起之后，其状态就变成挂起状态（也称静止状态）

* 挂起（静止）就绪状态：进程已具备运行条件，但目前位于外存中
* 挂起（静止）阻塞状态：进程在外存上等待某事件发生

引入挂起状态后，进程状态的转换又增加了从挂起状态到非挂起状态的转换，或者相反

### 5 原语 Primitive

是由若干条指令组成的、用于完成一定功能的一个过程。原语是原子操作，即一个操作中的动作要么全做，要么全不做，是一个不可分割的单位。在执行过程中不允许被中断

* Suspend原语将活动就绪的进程挂起，这个进程处于静止就绪
* Suspend原语将活动阻塞的进程挂起，这个进程处于静止阻塞
* Active原语将活动静止就绪的进程激活，这个进程处于活动就绪
* Active原语将静止阻塞的进程激活，这个进程处于活动阻塞（内存中）

### 6 阻塞原因的解除

排在静止阻塞队列的第一个进程可以进入静止就绪队列（外存中）

若阻塞原因解除，原则上无需换回内存，但是，如果

* 该进程有较高优先级
* 内存具有足够的内存空间

则进程被换回内存

### 7 创建状态和终止状态

#### （1）创建状态

创建一个进程可粗略划分成两个步骤

1. 为一个新进程创建PCB，并填写必要的管理信息
2. 把该进程转入就绪状态并插入就绪队列之中(进入内存，等待调度)

进程已拥有了自己的PCB，但进程自身还未进入主存，即上述①②两个步骤之间的状态就是创建状态

##### 引入创建状态：

1. 是为了保证进程的调度必须在创建工作完成后进行，以确保对进程控制块操作的完整性
2. 创建状态的引入，也增加了管理的灵活性，操作系统可以根据系统性能或主存容量的限制，推迟创建状态进程的提交

对于处于创建状态的进程，进入就绪队列后，进程状态便可由创建状态转入就绪状态
#### （2）终止状态

进程的终止：首先等待操作系统进行善后处理，然后将其PCB清零，并将PCB空间返还系统

进入终止状态条件

1. 到达了自然结束点
2. 出现了无法克服的错误
3. 被操作系统终结
4. 被其他有终止权的进程所终结

进入终止态的进程以后不能再执行，但在操作系统中依然保留一个记录，其中保存状态码和一些计时统计数据，供其它进程收集。一旦其它进程完成了对终止状态进程的信息提取之后，操作系统将删除该进程

![image-20200604175307330](C:\Users\10316\Documents\GitHub\learn_doc_md\操作系统\0x03-进程控制与状态转换.assets\image-20200604175307330.png)



