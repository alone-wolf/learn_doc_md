# 死锁

## 死锁的基本概念

### 死锁产生实例一组竞争系统资源或相互通信的进程相互的“永久”阻塞。若无外力作用，这组进程将永远不能继续执行

### 产生死锁的原因

* 资源数<要求该种资源的进程数
* 进程的推进顺序非法

### 产生死锁的四个必要条件

* 互斥条件+-9-*/74
  * 进程对所分配到的资源进行排它性使用，在一段时间内某资源只由一个进程占用
* 请求保持条件
  * 进程已经保持了至少一个资源，但又提出了新的资源请求，而该资源又已被其它进程占有，此时请求进程阻塞，但又对自己已获得的其它资源保持不放
* 不剥夺条件
  * 进程已获得的资源，不能被其他进程强行剥夺，只能该进程在使用完时由自己释放
* 环路条件
  * 发生死锁时，必然存在一个进程——资源的环形链，例如：进程集合{P0，P1，P2，…，Pn}中的P0》P1； P1》P2，…，Pn》P0

## 死锁的预防

### 采用预先静态分配方法

#### 互斥条件不可禁止 去掉“请求保持条件”

- 系统要求所有进程一次性地申请其所需地全部资源

##### 优点

- 方法简单

##### 缺点

- 进程延迟运行
- 资源浪费
- 用户有时提不出他要使用的全部资源

#### 去掉“不剥夺条件”

##### 方法

- 占有某些资源的进程，当它有新的资源请求被拒绝时，该进程停止运行，并释放它所占有的资源，当它再次被执行时，重新申请资源
- 如果一个进程请求另一个进程占有的资源，操作系统可以剥夺后者占有的资源，要求它释放资源并将资源分配给前者使用

##### 缺点

- 该策略实现起来比较复杂，而且要付出很大代价
- 反复申请、释放，使进程执行无限延迟，不仅延迟了周转时间。还增加了系统开销，降低了系统吞吐量

### 采用资源的有序分配

#### 去掉“环路”条件

- 令所有资源排队，并赋予不同的序号。当进程请求资源时，必须严格按递增的次序提出，从而消除了环路

#### 缺点

- 定好序号后，增加新设备类型受到限制
- 尽管定序号时考虑大多数作业使用资源的顺序。但会发生使用顺序与规定顺序不一致的情况，造成资源浪费
- 限制用户简单、自主地编程



死锁地预防措施低效！

## 死锁的避免

* 安全状态是指系统至少存在一个安全序列<P1，P2，。。。Pn>，按照这个序列为进程都可顺序完成
* 若系统不存在这样一个安全序列，则系统处于不安全状态

### 安全状态

![image-20200605233555109](C:\Users\10316\Documents\GitHub\learn_doc_md\操作系统\0x06-死锁.assets\image-20200605233555109.png)







## 死锁的检测与解除

