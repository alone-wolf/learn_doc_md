# Synchronized

首先还是祭出前辈的文章

[Java：手把手教你全面学习神秘的Synchronized关键字](https://www.jianshu.com/p/2ed498b43628)

## 简介

* 定义
	* java中的一个关键字
* 作用
	* 保证同一时刻最多只有一个线程执行 被Synchronized修饰的方法/代码
	* 其他线程必须等待当前线程执行完该方法/代码块后才能执行该方法
* 使用场景
	* 保证线程安全，解决多线程中的并发同步问题（实现的是阻塞并发）
	* 具体
		* 修饰 实例方法/代码块时，（同步）保护的是同一个对象方法的调用&当前实例类对象

## 具体使用

Synchronized 用于 修饰 代码块、类的实例方法 & 静态方法

### 使用规则

1. 锁对象设置
	1. 修饰代码块映射，需1个reference对象 作为锁的对象
	2. 修饰实例方法时，默认的锁对象 = 当前对象
	3. 修饰类方法（静态）时，默认的锁对象 = 当前类的class对象
2. 根据锁对象不同，一把锁同时最多只能被一个线程持有
	1. 若目标锁已被当前线程持有，其他线程只能阻塞等待当前线程释放目标锁
	2. 若当前线程已持有目标锁，其他线程仍然可以调用目标类中无被Synchronized修饰的方法
3. 当对象获取多个锁时，必须以相反的顺序释放&在与所有锁被获取时相同的词法范围内释放所有锁
	1. 若 线程 进入由线程已拥有的监控器保护的synchronized块，就允许线程继续运行
	2. 只有线程退出它进入的监控器保护的第一个synchronized块时，才释放锁
4. 特别注意
	1. java类中，实例对象会有多个，但只有1个class对象
		1. 即 类的不同实例 共享该类的class对象
		2. 实际上，class对象也属于java对象，只是有点特殊
	2. 静态方法&实例方法上的锁默认不一样
		1. 若同步则需制定两把锁
		2. 静态方法加锁，能和所有其他静态方法加锁的进行互斥
			1. 直接属于类，效果同xx.class锁

### 锁的类型&等级

| 类型                   | 定义                                                         | 作用                                        | 使用                                                         |
| ---------------------- | ------------------------------------------------------------ | ------------------------------------------- | ------------------------------------------------------------ |
| 对象锁                 | 含synchronized方法/代码块的类的实例对象                      | 控制同步方法之间的同步                      | 使用前必须先获得对象的锁（线程进入synchronized方法时获取该对象的锁，若此对象的对象锁已经被其他调用者占用，则需等待此锁被释放再进入），Java的所有对象都含有一个互斥锁，这个锁由jvm自动获取和释放，synchronized方法正常返回or抛异常而终止，jvm会自动释放对象锁（体现了synchronized来加锁的一个好处，方法抛出异常时，锁仍然可由jvm自动释放） |
| 方法锁（也属于对象锁） | 使用synchronized修饰的方法                                   | 同上                                        |                                                              |
| 类锁                   | 使用synchronized修饰 静态方法/代码块（类锁，实际上是锁class对象，但具体表现为 锁静态方法/代码块） | 控制静态方法（或 静态变量互斥体）之间的同步 |                                                              |

