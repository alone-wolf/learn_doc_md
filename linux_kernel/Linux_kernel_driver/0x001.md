# Linux 驱动

## 二 设备分类

1. 字符设备  --->>>  字符设备驱动  ---->> 字符设备文件
2. 网络设备  --->>>  网络设备驱动   --->>  没有设备文件
3. 块设备      --->>>  块设备驱动   ----- >>  块设备文件

### 字符设备

* IO传输过程中以字符为单位进行传输

* 用户对字符设备发出读写请求时,实际的硬件读写操作一般紧接着发生

### 块设备

* 块设备与字符设备相反,以块(4k内存缓冲)为数据传输单位
* 用户对块设备读写时,硬件上的读写操作不会紧接着发生,即用户请求和硬件操作是异步的
* 磁盘类 闪存类等设备都封装成块设备

### 网络设备

* 网络设备是一类特殊设备,它不像字符设备或块设备那样通过对应的设备文件访问,也不能直接通过read write进行数据请求,而是通过socket接口函数进行访问

## 三 字符设备驱动

1. 驱动编写
2. 驱动编译
3. 驱动使用

### 驱动编写

#### 模块化

* 使用模块的好处
  * 内核体积小 不需要的组件可以不编入内核
  * 开发灵活 模块可以同普通软件一样,从内核中添加或删除
  * 平台无关,节省内存
  * 可以动态加载

#### 结构(三要素)

`include<linux/init.h>`

`include<linux/module.h>`

1. 入口(加载)
   * module_init(入口函数名);
   * `int __init xxx_func(void){}`
2. 出口(卸载)
   * module_exit(卸载函数名);
   * `void __exit xxx_func(void){}`
3. GPL协议申明
   * MODULE_LICENSE("GPL");

#### 编译内核模块

编译器 gcc  交叉编译工具

编写编译内核模块的Makefile

* 内部编译 将内核模块源文件放在内核源码中进行编译,需要修改Kconfig Makefile, make menuconfig

* 静态编译 将内核模块编译进uImage中
* 外部编译 将内核模块源文件在内核源码以外进行编译
* 动态编译 编译生成动态模块xxx.ko

/// 这里,视频中老师用的是kernel-3.4.39

### 驱动编译



### 驱动使用